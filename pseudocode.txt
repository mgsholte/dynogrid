// All Pseudocode in here

// GRID CELL PASSER

// TODO: needs some work on properly separating the tasks onto their appropriate procs, i.e. giving vs taking

// this one's definitely not correct
trade_cells(grid_cells)
	for each (direction) // direction = left, right, up, down, forward, back
		take_cells(direction, grid_cells)
		give_cells(direction, grid_cells)
	end
end trade_cells

give_cells(direction, grid_cells)
	grid_cell** giving_cells
	grid_cell* neighbors = proc neighbors in that direction // use pxmins to compare proc positions?
	grid_cell* takers
	// the following may be unnecessary, since we follow with looping over takers. maybe combine both to one loop?
	for (neighbors)
		for (neighbor's ghost cells)
			if (cell->owner == pid) // this may be a false alarm often
				takers.add(neighbor)
				exit inner for loop
			end
		end
	end
	
	// get some sort of list of cells that are being passed. consider morton ids here? obviously comes from load balancer
	int* pass_ids
	
	for (takers)
		taker_ids = {}
		for (taker's ghost cells)
			if (taker_cell->owner == pid && pass_ids.contains(taker_cell->id)) // checking for right owner prob not necessary
				// taker changes
				pass particles from giver_cell to taker_cell // could use morton id to easily find giver cell; should this be per-cell or per-taker-proc?
				taker_ids.add(taker_cell->id)
				
				// giver changes
				giver_cell->owner = taker
				--xmax;
				// how do we deal with now-outdated ghosts? kill them or ignore them? killing means any ghosts at xmax+1 = NULL
			end
		end
		send_message(taker, taker_ids)
	end
	
end give_cells

take_cells(direction, grid_cells)
	// not clear how to write this
	recv_message(giver, taker_ids)
	for (taker_ids)
		convert_ghost2real_and_reghost(grid_cells, taker_id) // includes creating new ghosts as necessary
	end
end take_cells

// TODO: written only for x direction, need to generalize to y and z
convert_ghost2real_and_reghost(grid_cells, taker_id)
	cell->owner = pid
	if (taker_id.x == xmax)
		++xmax
		// init whole plane of new cells to NULL
		resize_allocation(grid_cells) // if necessary, re-allocates grid_cells with new padding on each side that is 50% of current length of real cells
		for (j = jmin:jmax)
			for (k = kmin:kmax)
				grid_cells[xmax-1][j][k] = NULL
			end
		end
	end
	for (neighbor cells of taker_id)
		if (neighbor == NULL)
			init cell
			laser(cell)
		end
	end
end convert

------------------------------------------------------------------------
OLD  OLD  OLD  OLD  OLD  OLD  OLD  OLD  OLD  OLD
------------------------------------------------------------------------
// All Pseudocode in here

update_grid
	foreach (grid_cell)
		update_grid_cell(grid_cell)
	end
	
update_grid_cell(grid_cell)
	if (grid_cell.children != NULL)
		bool want_coarsen = ask_to_coarsen(grid_cell)
		if (want_coarsen)
			coarsen(grid_cell)
		else
			foreach (child)
				update_grid_cell(child)
			end
		end
	else
		bool refined = ask_to_refine(grid_cell)
		(unfinished)